{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { makeDraggable } from './draggable.js';\nimport EventEmitter from './event-emitter.js';\nclass Renderer extends EventEmitter {\n  constructor(options, audioElement) {\n    super();\n    this.timeouts = [];\n    this.isScrollable = false;\n    this.audioData = null;\n    this.resizeObserver = null;\n    this.isDragging = false;\n    this.options = options;\n    const parent = this.parentFromOptionsContainer(options.container);\n    this.parent = parent;\n    const [div, shadow] = this.initHtml();\n    parent.appendChild(div);\n    this.container = div;\n    this.scrollContainer = shadow.querySelector('.scroll');\n    this.wrapper = shadow.querySelector('.wrapper');\n    this.canvasWrapper = shadow.querySelector('.canvases');\n    this.progressWrapper = shadow.querySelector('.progress');\n    this.cursor = shadow.querySelector('.cursor');\n    if (audioElement) {\n      shadow.appendChild(audioElement);\n    }\n    this.initEvents();\n  }\n  parentFromOptionsContainer(container) {\n    let parent;\n    if (typeof container === 'string') {\n      parent = document.querySelector(container);\n    } else if (container instanceof HTMLElement) {\n      parent = container;\n    }\n    if (!parent) {\n      throw new Error('Container not found');\n    }\n    return parent;\n  }\n  initEvents() {\n    const getClickPosition = e => {\n      const rect = this.wrapper.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientX - rect.left;\n      const relativeX = x / rect.width;\n      const relativeY = y / rect.height;\n      return [relativeX, relativeY];\n    };\n    // Add a click listener\n    this.wrapper.addEventListener('click', e => {\n      const [x, y] = getClickPosition(e);\n      this.emit('click', x, y);\n    });\n    // Add a double click listener\n    this.wrapper.addEventListener('dblclick', e => {\n      const [x, y] = getClickPosition(e);\n      this.emit('dblclick', x, y);\n    });\n    // Drag\n    if (this.options.dragToSeek) {\n      this.initDrag();\n    }\n    // Add a scroll listener\n    this.scrollContainer.addEventListener('scroll', () => {\n      const {\n        scrollLeft,\n        scrollWidth,\n        clientWidth\n      } = this.scrollContainer;\n      const startX = scrollLeft / scrollWidth;\n      const endX = (scrollLeft + clientWidth) / scrollWidth;\n      this.emit('scroll', startX, endX);\n    });\n    // Re-render the waveform on container resize\n    const delay = this.createDelay(100);\n    this.resizeObserver = new ResizeObserver(() => {\n      delay(() => this.reRender());\n    });\n    this.resizeObserver.observe(this.scrollContainer);\n  }\n  initDrag() {\n    makeDraggable(this.wrapper,\n    // On drag\n    (_, __, x) => {\n      this.emit('drag', Math.max(0, Math.min(1, x / this.wrapper.getBoundingClientRect().width)));\n    },\n    // On start drag\n    () => this.isDragging = true,\n    // On end drag\n    () => this.isDragging = false);\n  }\n  getHeight(optionsHeight) {\n    const defaultHeight = 128;\n    if (optionsHeight == null) return defaultHeight;\n    if (!isNaN(Number(optionsHeight))) return Number(optionsHeight);\n    if (optionsHeight === 'auto') return this.parent.clientHeight || defaultHeight;\n    return defaultHeight;\n  }\n  initHtml() {\n    const div = document.createElement('div');\n    const shadow = div.attachShadow({\n      mode: 'open'\n    });\n    shadow.innerHTML = \"\\n      <style>\\n        :host {\\n          user-select: none;\\n          min-width: 1px;\\n        }\\n        :host audio {\\n          display: block;\\n          width: 100%;\\n        }\\n        :host .scroll {\\n          overflow-x: auto;\\n          overflow-y: hidden;\\n          width: 100%;\\n          position: relative;\\n        }\\n        :host .noScrollbar {\\n          scrollbar-color: transparent;\\n          scrollbar-width: none;\\n        }\\n        :host .noScrollbar::-webkit-scrollbar {\\n          display: none;\\n          -webkit-appearance: none;\\n        }\\n        :host .wrapper {\\n          position: relative;\\n          overflow: visible;\\n          z-index: 2;\\n        }\\n        :host .canvases {\\n          min-height: \".concat(this.getHeight(this.options.height), \"px;\\n        }\\n        :host .canvases > div {\\n          position: relative;\\n        }\\n        :host canvas {\\n          display: block;\\n          position: absolute;\\n          top: 0;\\n          image-rendering: pixelated;\\n        }\\n        :host .progress {\\n          pointer-events: none;\\n          position: absolute;\\n          z-index: 2;\\n          top: 0;\\n          left: 0;\\n          width: 0;\\n          height: 100%;\\n          overflow: hidden;\\n        }\\n        :host .progress > div {\\n          position: relative;\\n        }\\n        :host .cursor {\\n          pointer-events: none;\\n          position: absolute;\\n          z-index: 5;\\n          top: 0;\\n          left: 0;\\n          height: 100%;\\n          border-radius: 2px;\\n        }\\n      </style>\\n\\n      <div class=\\\"scroll\\\" part=\\\"scroll\\\">\\n        <div class=\\\"wrapper\\\" part=\\\"wrapper\\\">\\n          <div class=\\\"canvases\\\"></div>\\n          <div class=\\\"progress\\\" part=\\\"progress\\\"></div>\\n          <div class=\\\"cursor\\\" part=\\\"cursor\\\"></div>\\n        </div>\\n      </div>\\n    \");\n    return [div, shadow];\n  }\n  /** Wavesurfer itself calls this method. Do not call it manually. */\n  setOptions(options) {\n    if (this.options.container !== options.container) {\n      const newParent = this.parentFromOptionsContainer(options.container);\n      newParent.appendChild(this.container);\n      this.parent = newParent;\n    }\n    if (options.dragToSeek && !this.options.dragToSeek) {\n      this.initDrag();\n    }\n    this.options = options;\n    // Re-render the waveform\n    this.reRender();\n  }\n  getWrapper() {\n    return this.wrapper;\n  }\n  getScroll() {\n    return this.scrollContainer.scrollLeft;\n  }\n  destroy() {\n    var _a;\n    this.container.remove();\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n  }\n  createDelay() {\n    let delayMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    const context = {};\n    this.timeouts.push(context);\n    return callback => {\n      context.timeout && clearTimeout(context.timeout);\n      context.timeout = setTimeout(callback, delayMs);\n    };\n  }\n  // Convert array of color values to linear gradient\n  convertColorValues(color) {\n    if (!Array.isArray(color)) return color || '';\n    if (color.length < 2) return color[0] || '';\n    const canvasElement = document.createElement('canvas');\n    const ctx = canvasElement.getContext('2d');\n    const gradientHeight = canvasElement.height * (window.devicePixelRatio || 1);\n    const gradient = ctx.createLinearGradient(0, 0, 0, gradientHeight);\n    const colorStopPercentage = 1 / (color.length - 1);\n    color.forEach((color, index) => {\n      const offset = index * colorStopPercentage;\n      gradient.addColorStop(offset, color);\n    });\n    return gradient;\n  }\n  renderBarWaveform(channelData, options, ctx, vScale) {\n    const topChannel = channelData[0];\n    const bottomChannel = channelData[1] || channelData[0];\n    const length = topChannel.length;\n    const {\n      width,\n      height\n    } = ctx.canvas;\n    const halfHeight = height / 2;\n    const pixelRatio = window.devicePixelRatio || 1;\n    const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;\n    const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;\n    const barRadius = options.barRadius || 0;\n    const barIndexScale = width / (barWidth + barGap) / length;\n    const rectFn = barRadius && 'roundRect' in ctx ? 'roundRect' : 'rect';\n    ctx.beginPath();\n    let prevX = 0;\n    let maxTop = 0;\n    let maxBottom = 0;\n    for (let i = 0; i <= length; i++) {\n      const x = Math.round(i * barIndexScale);\n      if (x > prevX) {\n        const topBarHeight = Math.round(maxTop * halfHeight * vScale);\n        const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);\n        const barHeight = topBarHeight + bottomBarHeight || 1;\n        // Vertical alignment\n        let y = halfHeight - topBarHeight;\n        if (options.barAlign === 'top') {\n          y = 0;\n        } else if (options.barAlign === 'bottom') {\n          y = height - barHeight;\n        }\n        ctx[rectFn](prevX * (barWidth + barGap), y, barWidth, barHeight, barRadius);\n        prevX = x;\n        maxTop = 0;\n        maxBottom = 0;\n      }\n      const magnitudeTop = Math.abs(topChannel[i] || 0);\n      const magnitudeBottom = Math.abs(bottomChannel[i] || 0);\n      if (magnitudeTop > maxTop) maxTop = magnitudeTop;\n      if (magnitudeBottom > maxBottom) maxBottom = magnitudeBottom;\n    }\n    ctx.fill();\n    ctx.closePath();\n  }\n  renderLineWaveform(channelData, _options, ctx, vScale) {\n    const drawChannel = index => {\n      const channel = channelData[index] || channelData[0];\n      const length = channel.length;\n      const {\n        height\n      } = ctx.canvas;\n      const halfHeight = height / 2;\n      const hScale = ctx.canvas.width / length;\n      ctx.moveTo(0, halfHeight);\n      let prevX = 0;\n      let max = 0;\n      for (let i = 0; i <= length; i++) {\n        const x = Math.round(i * hScale);\n        if (x > prevX) {\n          const h = Math.round(max * halfHeight * vScale) || 1;\n          const y = halfHeight + h * (index === 0 ? -1 : 1);\n          ctx.lineTo(prevX, y);\n          prevX = x;\n          max = 0;\n        }\n        const value = Math.abs(channel[i] || 0);\n        if (value > max) max = value;\n      }\n      ctx.lineTo(prevX, halfHeight);\n    };\n    ctx.beginPath();\n    drawChannel(0);\n    drawChannel(1);\n    ctx.fill();\n    ctx.closePath();\n  }\n  renderWaveform(channelData, options, ctx) {\n    ctx.fillStyle = this.convertColorValues(options.waveColor);\n    // Custom rendering function\n    if (options.renderFunction) {\n      options.renderFunction(channelData, ctx);\n      return;\n    }\n    // Vertical scaling\n    let vScale = options.barHeight || 1;\n    if (options.normalize) {\n      const max = Array.from(channelData[0]).reduce((max, value) => Math.max(max, Math.abs(value)), 0);\n      vScale = max ? 1 / max : 1;\n    }\n    // Render waveform as bars\n    if (options.barWidth || options.barGap || options.barAlign) {\n      this.renderBarWaveform(channelData, options, ctx, vScale);\n      return;\n    }\n    // Render waveform as a polyline\n    this.renderLineWaveform(channelData, options, ctx, vScale);\n  }\n  renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {\n    const pixelRatio = window.devicePixelRatio || 1;\n    const canvas = document.createElement('canvas');\n    const length = channelData[0].length;\n    canvas.width = Math.round(width * (end - start) / length);\n    canvas.height = height * pixelRatio;\n    canvas.style.width = \"\".concat(Math.floor(canvas.width / pixelRatio), \"px\");\n    canvas.style.height = \"\".concat(height, \"px\");\n    canvas.style.left = \"\".concat(Math.floor(start * width / pixelRatio / length), \"px\");\n    canvasContainer.appendChild(canvas);\n    const ctx = canvas.getContext('2d');\n    this.renderWaveform(channelData.map(channel => channel.slice(start, end)), options, ctx);\n    // Draw a progress canvas\n    if (canvas.width > 0 && canvas.height > 0) {\n      const progressCanvas = canvas.cloneNode();\n      const progressCtx = progressCanvas.getContext('2d');\n      progressCtx.drawImage(canvas, 0, 0);\n      // Set the composition method to draw only where the waveform is drawn\n      progressCtx.globalCompositeOperation = 'source-in';\n      progressCtx.fillStyle = this.convertColorValues(options.progressColor);\n      // This rectangle acts as a mask thanks to the composition method\n      progressCtx.fillRect(0, 0, canvas.width, canvas.height);\n      progressContainer.appendChild(progressCanvas);\n    }\n  }\n  renderChannel(channelData, options, width) {\n    // A container for canvases\n    const canvasContainer = document.createElement('div');\n    const height = this.getHeight(options.height);\n    canvasContainer.style.height = \"\".concat(height, \"px\");\n    this.canvasWrapper.style.minHeight = \"\".concat(height, \"px\");\n    this.canvasWrapper.appendChild(canvasContainer);\n    // A container for progress canvases\n    const progressContainer = canvasContainer.cloneNode();\n    this.progressWrapper.appendChild(progressContainer);\n    // Determine the currently visible part of the waveform\n    const {\n      scrollLeft,\n      scrollWidth,\n      clientWidth\n    } = this.scrollContainer;\n    const len = channelData[0].length;\n    const scale = len / scrollWidth;\n    let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);\n    // Adjust width to avoid gaps between canvases when using bars\n    if (options.barWidth || options.barGap) {\n      const barWidth = options.barWidth || 0.5;\n      const barGap = options.barGap || barWidth / 2;\n      const totalBarWidth = barWidth + barGap;\n      if (viewportWidth % totalBarWidth !== 0) {\n        viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;\n      }\n    }\n    const start = Math.floor(Math.abs(scrollLeft) * scale);\n    const end = Math.floor(start + viewportWidth * scale);\n    const viewportLen = end - start;\n    // Draw a portion of the waveform from start peak to end peak\n    const draw = (start, end) => {\n      this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start), Math.min(end, len), canvasContainer, progressContainer);\n    };\n    // Draw the waveform in viewport chunks, each with a delay\n    const headDelay = this.createDelay();\n    const tailDelay = this.createDelay();\n    const renderHead = (fromIndex, toIndex) => {\n      draw(fromIndex, toIndex);\n      if (fromIndex > 0) {\n        headDelay(() => {\n          renderHead(fromIndex - viewportLen, toIndex - viewportLen);\n        });\n      }\n    };\n    const renderTail = (fromIndex, toIndex) => {\n      draw(fromIndex, toIndex);\n      if (toIndex < len) {\n        tailDelay(() => {\n          renderTail(fromIndex + viewportLen, toIndex + viewportLen);\n        });\n      }\n    };\n    renderHead(start, end);\n    if (end < len) {\n      renderTail(end, end + viewportLen);\n    }\n  }\n  render(audioData) {\n    // Clear previous timeouts\n    this.timeouts.forEach(context => context.timeout && clearTimeout(context.timeout));\n    this.timeouts = [];\n    // Clear the canvases\n    this.canvasWrapper.innerHTML = '';\n    this.progressWrapper.innerHTML = '';\n    // Width\n    if (this.options.width != null) {\n      this.scrollContainer.style.width = typeof this.options.width === 'number' ? \"\".concat(this.options.width, \"px\") : this.options.width;\n    }\n    // Determine the width of the waveform\n    const pixelRatio = window.devicePixelRatio || 1;\n    const parentWidth = this.scrollContainer.clientWidth;\n    const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));\n    // Whether the container should scroll\n    this.isScrollable = scrollWidth > parentWidth;\n    const useParentWidth = this.options.fillParent && !this.isScrollable;\n    // Width of the waveform in pixels\n    const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;\n    // Set the width of the wrapper\n    this.wrapper.style.width = useParentWidth ? '100%' : \"\".concat(scrollWidth, \"px\");\n    // Set additional styles\n    this.scrollContainer.style.overflowX = this.isScrollable ? 'auto' : 'hidden';\n    this.scrollContainer.classList.toggle('noScrollbar', !!this.options.hideScrollbar);\n    this.cursor.style.backgroundColor = \"\".concat(this.options.cursorColor || this.options.progressColor);\n    this.cursor.style.width = \"\".concat(this.options.cursorWidth, \"px\");\n    // Render the waveform\n    if (this.options.splitChannels) {\n      // Render a waveform for each channel\n      for (let i = 0; i < audioData.numberOfChannels; i++) {\n        const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i]);\n        this.renderChannel([audioData.getChannelData(i)], options, width);\n      }\n    } else {\n      // Render a single waveform for the first two channels (left and right)\n      const channels = [audioData.getChannelData(0)];\n      if (audioData.numberOfChannels > 1) channels.push(audioData.getChannelData(1));\n      this.renderChannel(channels, this.options, width);\n    }\n    this.audioData = audioData;\n    this.emit('render');\n  }\n  reRender() {\n    // Return if the waveform has not been rendered yet\n    if (!this.audioData) return;\n    // Remember the current cursor position\n    const {\n      scrollWidth\n    } = this.scrollContainer;\n    const oldCursorPosition = this.progressWrapper.clientWidth;\n    // Re-render the waveform\n    this.render(this.audioData);\n    // Adjust the scroll position so that the cursor stays in the same place\n    if (this.isScrollable && scrollWidth !== this.scrollContainer.scrollWidth) {\n      const newCursorPosition = this.progressWrapper.clientWidth;\n      this.scrollContainer.scrollLeft += newCursorPosition - oldCursorPosition;\n    }\n  }\n  zoom(minPxPerSec) {\n    this.options.minPxPerSec = minPxPerSec;\n    this.reRender();\n  }\n  scrollIntoView(progress) {\n    let isPlaying = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      clientWidth,\n      scrollLeft,\n      scrollWidth\n    } = this.scrollContainer;\n    const progressWidth = scrollWidth * progress;\n    const center = clientWidth / 2;\n    const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;\n    if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {\n      // Scroll to the center\n      if (this.options.autoCenter && !this.isDragging) {\n        // If the cursor is in viewport but not centered, scroll to the center slowly\n        const minDiff = center / 20;\n        if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {\n          this.scrollContainer.scrollLeft += minDiff;\n        } else {\n          // Otherwise, scroll to the center immediately\n          this.scrollContainer.scrollLeft = progressWidth - center;\n        }\n      } else if (this.isDragging) {\n        // Scroll just a little bit to allow for some space between the cursor and the edge\n        const gap = 10;\n        this.scrollContainer.scrollLeft = progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;\n      } else {\n        // Scroll to the beginning\n        this.scrollContainer.scrollLeft = progressWidth;\n      }\n    }\n    // Emit the scroll event\n    {\n      const {\n        scrollLeft\n      } = this.scrollContainer;\n      const startX = scrollLeft / scrollWidth;\n      const endX = (scrollLeft + clientWidth) / scrollWidth;\n      this.emit('scroll', startX, endX);\n    }\n  }\n  renderProgress(progress, isPlaying) {\n    if (isNaN(progress)) return;\n    const percents = progress * 100;\n    this.canvasWrapper.style.clipPath = \"polygon(\".concat(percents, \"% 0, 100% 0, 100% 100%, \").concat(percents, \"% 100%)\");\n    this.progressWrapper.style.width = \"\".concat(percents, \"%\");\n    this.cursor.style.left = \"\".concat(percents, \"%\");\n    this.cursor.style.marginLeft = Math.round(percents) === 100 ? \"-\".concat(this.options.cursorWidth, \"px\") : '';\n    if (this.isScrollable && this.options.autoScroll) {\n      this.scrollIntoView(progress, isPlaying);\n    }\n  }\n  exportImage(format, quality, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const canvases = this.canvasWrapper.querySelectorAll('canvas');\n      if (!canvases.length) {\n        throw new Error('No waveform data');\n      }\n      // Data URLs\n      if (type === 'dataURL') {\n        const images = Array.from(canvases).map(canvas => canvas.toDataURL(format, quality));\n        return Promise.resolve(images);\n      }\n      // Blobs\n      return Promise.all(Array.from(canvases).map(canvas => {\n        return new Promise((resolve, reject) => {\n          canvas.toBlob(blob => {\n            blob ? resolve(blob) : reject(new Error('Could not export image'));\n          }, format, quality);\n        });\n      }));\n    });\n  }\n}\nRenderer.MAX_CANVAS_WIDTH = 4000;\nexport default Renderer;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","makeDraggable","EventEmitter","Renderer","constructor","options","audioElement","timeouts","isScrollable","audioData","resizeObserver","isDragging","parent","parentFromOptionsContainer","container","div","shadow","initHtml","appendChild","scrollContainer","querySelector","wrapper","canvasWrapper","progressWrapper","cursor","initEvents","document","HTMLElement","Error","getClickPosition","rect","getBoundingClientRect","x","clientX","left","y","relativeX","width","relativeY","height","addEventListener","emit","dragToSeek","initDrag","scrollLeft","scrollWidth","clientWidth","startX","endX","delay","createDelay","ResizeObserver","reRender","observe","_","__","Math","max","min","getHeight","optionsHeight","defaultHeight","isNaN","Number","clientHeight","createElement","attachShadow","mode","innerHTML","concat","setOptions","newParent","getWrapper","getScroll","destroy","_a","remove","disconnect","delayMs","arguments","length","undefined","context","push","callback","timeout","clearTimeout","setTimeout","convertColorValues","color","Array","isArray","canvasElement","ctx","getContext","gradientHeight","window","devicePixelRatio","gradient","createLinearGradient","colorStopPercentage","forEach","index","offset","addColorStop","renderBarWaveform","channelData","vScale","topChannel","bottomChannel","canvas","halfHeight","pixelRatio","barWidth","barGap","barRadius","barIndexScale","rectFn","beginPath","prevX","maxTop","maxBottom","i","round","topBarHeight","bottomBarHeight","barHeight","barAlign","magnitudeTop","abs","magnitudeBottom","fill","closePath","renderLineWaveform","_options","drawChannel","channel","hScale","moveTo","h","lineTo","renderWaveform","fillStyle","waveColor","renderFunction","normalize","from","reduce","renderSingleCanvas","start","end","canvasContainer","progressContainer","style","floor","map","slice","progressCanvas","cloneNode","progressCtx","drawImage","globalCompositeOperation","progressColor","fillRect","renderChannel","minHeight","len","scale","viewportWidth","MAX_CANVAS_WIDTH","totalBarWidth","viewportLen","draw","headDelay","tailDelay","renderHead","fromIndex","toIndex","renderTail","render","parentWidth","ceil","duration","minPxPerSec","useParentWidth","fillParent","overflowX","classList","toggle","hideScrollbar","backgroundColor","cursorColor","cursorWidth","splitChannels","numberOfChannels","Object","assign","getChannelData","channels","oldCursorPosition","newCursorPosition","zoom","scrollIntoView","progress","isPlaying","progressWidth","center","minScroll","autoCenter","minDiff","gap","renderProgress","percents","clipPath","marginLeft","autoScroll","exportImage","format","quality","type","canvases","querySelectorAll","images","toDataURL","all","toBlob","blob"],"sources":["C:/dev/PROJECT_TOTAL/src/main/react/node_modules/wavesurfer.js/dist/renderer.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { makeDraggable } from './draggable.js';\nimport EventEmitter from './event-emitter.js';\nclass Renderer extends EventEmitter {\n    constructor(options, audioElement) {\n        super();\n        this.timeouts = [];\n        this.isScrollable = false;\n        this.audioData = null;\n        this.resizeObserver = null;\n        this.isDragging = false;\n        this.options = options;\n        const parent = this.parentFromOptionsContainer(options.container);\n        this.parent = parent;\n        const [div, shadow] = this.initHtml();\n        parent.appendChild(div);\n        this.container = div;\n        this.scrollContainer = shadow.querySelector('.scroll');\n        this.wrapper = shadow.querySelector('.wrapper');\n        this.canvasWrapper = shadow.querySelector('.canvases');\n        this.progressWrapper = shadow.querySelector('.progress');\n        this.cursor = shadow.querySelector('.cursor');\n        if (audioElement) {\n            shadow.appendChild(audioElement);\n        }\n        this.initEvents();\n    }\n    parentFromOptionsContainer(container) {\n        let parent;\n        if (typeof container === 'string') {\n            parent = document.querySelector(container);\n        }\n        else if (container instanceof HTMLElement) {\n            parent = container;\n        }\n        if (!parent) {\n            throw new Error('Container not found');\n        }\n        return parent;\n    }\n    initEvents() {\n        const getClickPosition = (e) => {\n            const rect = this.wrapper.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientX - rect.left;\n            const relativeX = x / rect.width;\n            const relativeY = y / rect.height;\n            return [relativeX, relativeY];\n        };\n        // Add a click listener\n        this.wrapper.addEventListener('click', (e) => {\n            const [x, y] = getClickPosition(e);\n            this.emit('click', x, y);\n        });\n        // Add a double click listener\n        this.wrapper.addEventListener('dblclick', (e) => {\n            const [x, y] = getClickPosition(e);\n            this.emit('dblclick', x, y);\n        });\n        // Drag\n        if (this.options.dragToSeek) {\n            this.initDrag();\n        }\n        // Add a scroll listener\n        this.scrollContainer.addEventListener('scroll', () => {\n            const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        });\n        // Re-render the waveform on container resize\n        const delay = this.createDelay(100);\n        this.resizeObserver = new ResizeObserver(() => {\n            delay(() => this.reRender());\n        });\n        this.resizeObserver.observe(this.scrollContainer);\n    }\n    initDrag() {\n        makeDraggable(this.wrapper, \n        // On drag\n        (_, __, x) => {\n            this.emit('drag', Math.max(0, Math.min(1, x / this.wrapper.getBoundingClientRect().width)));\n        }, \n        // On start drag\n        () => (this.isDragging = true), \n        // On end drag\n        () => (this.isDragging = false));\n    }\n    getHeight(optionsHeight) {\n        const defaultHeight = 128;\n        if (optionsHeight == null)\n            return defaultHeight;\n        if (!isNaN(Number(optionsHeight)))\n            return Number(optionsHeight);\n        if (optionsHeight === 'auto')\n            return this.parent.clientHeight || defaultHeight;\n        return defaultHeight;\n    }\n    initHtml() {\n        const div = document.createElement('div');\n        const shadow = div.attachShadow({ mode: 'open' });\n        shadow.innerHTML = `\n      <style>\n        :host {\n          user-select: none;\n          min-width: 1px;\n        }\n        :host audio {\n          display: block;\n          width: 100%;\n        }\n        :host .scroll {\n          overflow-x: auto;\n          overflow-y: hidden;\n          width: 100%;\n          position: relative;\n        }\n        :host .noScrollbar {\n          scrollbar-color: transparent;\n          scrollbar-width: none;\n        }\n        :host .noScrollbar::-webkit-scrollbar {\n          display: none;\n          -webkit-appearance: none;\n        }\n        :host .wrapper {\n          position: relative;\n          overflow: visible;\n          z-index: 2;\n        }\n        :host .canvases {\n          min-height: ${this.getHeight(this.options.height)}px;\n        }\n        :host .canvases > div {\n          position: relative;\n        }\n        :host canvas {\n          display: block;\n          position: absolute;\n          top: 0;\n          image-rendering: pixelated;\n        }\n        :host .progress {\n          pointer-events: none;\n          position: absolute;\n          z-index: 2;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        :host .progress > div {\n          position: relative;\n        }\n        :host .cursor {\n          pointer-events: none;\n          position: absolute;\n          z-index: 5;\n          top: 0;\n          left: 0;\n          height: 100%;\n          border-radius: 2px;\n        }\n      </style>\n\n      <div class=\"scroll\" part=\"scroll\">\n        <div class=\"wrapper\" part=\"wrapper\">\n          <div class=\"canvases\"></div>\n          <div class=\"progress\" part=\"progress\"></div>\n          <div class=\"cursor\" part=\"cursor\"></div>\n        </div>\n      </div>\n    `;\n        return [div, shadow];\n    }\n    /** Wavesurfer itself calls this method. Do not call it manually. */\n    setOptions(options) {\n        if (this.options.container !== options.container) {\n            const newParent = this.parentFromOptionsContainer(options.container);\n            newParent.appendChild(this.container);\n            this.parent = newParent;\n        }\n        if (options.dragToSeek && !this.options.dragToSeek) {\n            this.initDrag();\n        }\n        this.options = options;\n        // Re-render the waveform\n        this.reRender();\n    }\n    getWrapper() {\n        return this.wrapper;\n    }\n    getScroll() {\n        return this.scrollContainer.scrollLeft;\n    }\n    destroy() {\n        var _a;\n        this.container.remove();\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    createDelay(delayMs = 10) {\n        const context = {};\n        this.timeouts.push(context);\n        return (callback) => {\n            context.timeout && clearTimeout(context.timeout);\n            context.timeout = setTimeout(callback, delayMs);\n        };\n    }\n    // Convert array of color values to linear gradient\n    convertColorValues(color) {\n        if (!Array.isArray(color))\n            return color || '';\n        if (color.length < 2)\n            return color[0] || '';\n        const canvasElement = document.createElement('canvas');\n        const ctx = canvasElement.getContext('2d');\n        const gradientHeight = canvasElement.height * (window.devicePixelRatio || 1);\n        const gradient = ctx.createLinearGradient(0, 0, 0, gradientHeight);\n        const colorStopPercentage = 1 / (color.length - 1);\n        color.forEach((color, index) => {\n            const offset = index * colorStopPercentage;\n            gradient.addColorStop(offset, color);\n        });\n        return gradient;\n    }\n    renderBarWaveform(channelData, options, ctx, vScale) {\n        const topChannel = channelData[0];\n        const bottomChannel = channelData[1] || channelData[0];\n        const length = topChannel.length;\n        const { width, height } = ctx.canvas;\n        const halfHeight = height / 2;\n        const pixelRatio = window.devicePixelRatio || 1;\n        const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;\n        const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;\n        const barRadius = options.barRadius || 0;\n        const barIndexScale = width / (barWidth + barGap) / length;\n        const rectFn = barRadius && 'roundRect' in ctx ? 'roundRect' : 'rect';\n        ctx.beginPath();\n        let prevX = 0;\n        let maxTop = 0;\n        let maxBottom = 0;\n        for (let i = 0; i <= length; i++) {\n            const x = Math.round(i * barIndexScale);\n            if (x > prevX) {\n                const topBarHeight = Math.round(maxTop * halfHeight * vScale);\n                const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);\n                const barHeight = topBarHeight + bottomBarHeight || 1;\n                // Vertical alignment\n                let y = halfHeight - topBarHeight;\n                if (options.barAlign === 'top') {\n                    y = 0;\n                }\n                else if (options.barAlign === 'bottom') {\n                    y = height - barHeight;\n                }\n                ctx[rectFn](prevX * (barWidth + barGap), y, barWidth, barHeight, barRadius);\n                prevX = x;\n                maxTop = 0;\n                maxBottom = 0;\n            }\n            const magnitudeTop = Math.abs(topChannel[i] || 0);\n            const magnitudeBottom = Math.abs(bottomChannel[i] || 0);\n            if (magnitudeTop > maxTop)\n                maxTop = magnitudeTop;\n            if (magnitudeBottom > maxBottom)\n                maxBottom = magnitudeBottom;\n        }\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderLineWaveform(channelData, _options, ctx, vScale) {\n        const drawChannel = (index) => {\n            const channel = channelData[index] || channelData[0];\n            const length = channel.length;\n            const { height } = ctx.canvas;\n            const halfHeight = height / 2;\n            const hScale = ctx.canvas.width / length;\n            ctx.moveTo(0, halfHeight);\n            let prevX = 0;\n            let max = 0;\n            for (let i = 0; i <= length; i++) {\n                const x = Math.round(i * hScale);\n                if (x > prevX) {\n                    const h = Math.round(max * halfHeight * vScale) || 1;\n                    const y = halfHeight + h * (index === 0 ? -1 : 1);\n                    ctx.lineTo(prevX, y);\n                    prevX = x;\n                    max = 0;\n                }\n                const value = Math.abs(channel[i] || 0);\n                if (value > max)\n                    max = value;\n            }\n            ctx.lineTo(prevX, halfHeight);\n        };\n        ctx.beginPath();\n        drawChannel(0);\n        drawChannel(1);\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderWaveform(channelData, options, ctx) {\n        ctx.fillStyle = this.convertColorValues(options.waveColor);\n        // Custom rendering function\n        if (options.renderFunction) {\n            options.renderFunction(channelData, ctx);\n            return;\n        }\n        // Vertical scaling\n        let vScale = options.barHeight || 1;\n        if (options.normalize) {\n            const max = Array.from(channelData[0]).reduce((max, value) => Math.max(max, Math.abs(value)), 0);\n            vScale = max ? 1 / max : 1;\n        }\n        // Render waveform as bars\n        if (options.barWidth || options.barGap || options.barAlign) {\n            this.renderBarWaveform(channelData, options, ctx, vScale);\n            return;\n        }\n        // Render waveform as a polyline\n        this.renderLineWaveform(channelData, options, ctx, vScale);\n    }\n    renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        const canvas = document.createElement('canvas');\n        const length = channelData[0].length;\n        canvas.width = Math.round((width * (end - start)) / length);\n        canvas.height = height * pixelRatio;\n        canvas.style.width = `${Math.floor(canvas.width / pixelRatio)}px`;\n        canvas.style.height = `${height}px`;\n        canvas.style.left = `${Math.floor((start * width) / pixelRatio / length)}px`;\n        canvasContainer.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        this.renderWaveform(channelData.map((channel) => channel.slice(start, end)), options, ctx);\n        // Draw a progress canvas\n        if (canvas.width > 0 && canvas.height > 0) {\n            const progressCanvas = canvas.cloneNode();\n            const progressCtx = progressCanvas.getContext('2d');\n            progressCtx.drawImage(canvas, 0, 0);\n            // Set the composition method to draw only where the waveform is drawn\n            progressCtx.globalCompositeOperation = 'source-in';\n            progressCtx.fillStyle = this.convertColorValues(options.progressColor);\n            // This rectangle acts as a mask thanks to the composition method\n            progressCtx.fillRect(0, 0, canvas.width, canvas.height);\n            progressContainer.appendChild(progressCanvas);\n        }\n    }\n    renderChannel(channelData, options, width) {\n        // A container for canvases\n        const canvasContainer = document.createElement('div');\n        const height = this.getHeight(options.height);\n        canvasContainer.style.height = `${height}px`;\n        this.canvasWrapper.style.minHeight = `${height}px`;\n        this.canvasWrapper.appendChild(canvasContainer);\n        // A container for progress canvases\n        const progressContainer = canvasContainer.cloneNode();\n        this.progressWrapper.appendChild(progressContainer);\n        // Determine the currently visible part of the waveform\n        const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n        const len = channelData[0].length;\n        const scale = len / scrollWidth;\n        let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);\n        // Adjust width to avoid gaps between canvases when using bars\n        if (options.barWidth || options.barGap) {\n            const barWidth = options.barWidth || 0.5;\n            const barGap = options.barGap || barWidth / 2;\n            const totalBarWidth = barWidth + barGap;\n            if (viewportWidth % totalBarWidth !== 0) {\n                viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;\n            }\n        }\n        const start = Math.floor(Math.abs(scrollLeft) * scale);\n        const end = Math.floor(start + viewportWidth * scale);\n        const viewportLen = end - start;\n        // Draw a portion of the waveform from start peak to end peak\n        const draw = (start, end) => {\n            this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start), Math.min(end, len), canvasContainer, progressContainer);\n        };\n        // Draw the waveform in viewport chunks, each with a delay\n        const headDelay = this.createDelay();\n        const tailDelay = this.createDelay();\n        const renderHead = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (fromIndex > 0) {\n                headDelay(() => {\n                    renderHead(fromIndex - viewportLen, toIndex - viewportLen);\n                });\n            }\n        };\n        const renderTail = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (toIndex < len) {\n                tailDelay(() => {\n                    renderTail(fromIndex + viewportLen, toIndex + viewportLen);\n                });\n            }\n        };\n        renderHead(start, end);\n        if (end < len) {\n            renderTail(end, end + viewportLen);\n        }\n    }\n    render(audioData) {\n        // Clear previous timeouts\n        this.timeouts.forEach((context) => context.timeout && clearTimeout(context.timeout));\n        this.timeouts = [];\n        // Clear the canvases\n        this.canvasWrapper.innerHTML = '';\n        this.progressWrapper.innerHTML = '';\n        // Width\n        if (this.options.width != null) {\n            this.scrollContainer.style.width =\n                typeof this.options.width === 'number' ? `${this.options.width}px` : this.options.width;\n        }\n        // Determine the width of the waveform\n        const pixelRatio = window.devicePixelRatio || 1;\n        const parentWidth = this.scrollContainer.clientWidth;\n        const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));\n        // Whether the container should scroll\n        this.isScrollable = scrollWidth > parentWidth;\n        const useParentWidth = this.options.fillParent && !this.isScrollable;\n        // Width of the waveform in pixels\n        const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;\n        // Set the width of the wrapper\n        this.wrapper.style.width = useParentWidth ? '100%' : `${scrollWidth}px`;\n        // Set additional styles\n        this.scrollContainer.style.overflowX = this.isScrollable ? 'auto' : 'hidden';\n        this.scrollContainer.classList.toggle('noScrollbar', !!this.options.hideScrollbar);\n        this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;\n        this.cursor.style.width = `${this.options.cursorWidth}px`;\n        // Render the waveform\n        if (this.options.splitChannels) {\n            // Render a waveform for each channel\n            for (let i = 0; i < audioData.numberOfChannels; i++) {\n                const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i]);\n                this.renderChannel([audioData.getChannelData(i)], options, width);\n            }\n        }\n        else {\n            // Render a single waveform for the first two channels (left and right)\n            const channels = [audioData.getChannelData(0)];\n            if (audioData.numberOfChannels > 1)\n                channels.push(audioData.getChannelData(1));\n            this.renderChannel(channels, this.options, width);\n        }\n        this.audioData = audioData;\n        this.emit('render');\n    }\n    reRender() {\n        // Return if the waveform has not been rendered yet\n        if (!this.audioData)\n            return;\n        // Remember the current cursor position\n        const { scrollWidth } = this.scrollContainer;\n        const oldCursorPosition = this.progressWrapper.clientWidth;\n        // Re-render the waveform\n        this.render(this.audioData);\n        // Adjust the scroll position so that the cursor stays in the same place\n        if (this.isScrollable && scrollWidth !== this.scrollContainer.scrollWidth) {\n            const newCursorPosition = this.progressWrapper.clientWidth;\n            this.scrollContainer.scrollLeft += newCursorPosition - oldCursorPosition;\n        }\n    }\n    zoom(minPxPerSec) {\n        this.options.minPxPerSec = minPxPerSec;\n        this.reRender();\n    }\n    scrollIntoView(progress, isPlaying = false) {\n        const { clientWidth, scrollLeft, scrollWidth } = this.scrollContainer;\n        const progressWidth = scrollWidth * progress;\n        const center = clientWidth / 2;\n        const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;\n        if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {\n            // Scroll to the center\n            if (this.options.autoCenter && !this.isDragging) {\n                // If the cursor is in viewport but not centered, scroll to the center slowly\n                const minDiff = center / 20;\n                if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {\n                    this.scrollContainer.scrollLeft += minDiff;\n                }\n                else {\n                    // Otherwise, scroll to the center immediately\n                    this.scrollContainer.scrollLeft = progressWidth - center;\n                }\n            }\n            else if (this.isDragging) {\n                // Scroll just a little bit to allow for some space between the cursor and the edge\n                const gap = 10;\n                this.scrollContainer.scrollLeft =\n                    progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;\n            }\n            else {\n                // Scroll to the beginning\n                this.scrollContainer.scrollLeft = progressWidth;\n            }\n        }\n        // Emit the scroll event\n        {\n            const { scrollLeft } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        }\n    }\n    renderProgress(progress, isPlaying) {\n        if (isNaN(progress))\n            return;\n        const percents = progress * 100;\n        this.canvasWrapper.style.clipPath = `polygon(${percents}% 0, 100% 0, 100% 100%, ${percents}% 100%)`;\n        this.progressWrapper.style.width = `${percents}%`;\n        this.cursor.style.left = `${percents}%`;\n        this.cursor.style.marginLeft = Math.round(percents) === 100 ? `-${this.options.cursorWidth}px` : '';\n        if (this.isScrollable && this.options.autoScroll) {\n            this.scrollIntoView(progress, isPlaying);\n        }\n    }\n    exportImage(format, quality, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const canvases = this.canvasWrapper.querySelectorAll('canvas');\n            if (!canvases.length) {\n                throw new Error('No waveform data');\n            }\n            // Data URLs\n            if (type === 'dataURL') {\n                const images = Array.from(canvases).map((canvas) => canvas.toDataURL(format, quality));\n                return Promise.resolve(images);\n            }\n            // Blobs\n            return Promise.all(Array.from(canvases).map((canvas) => {\n                return new Promise((resolve, reject) => {\n                    canvas.toBlob((blob) => {\n                        blob ? resolve(blob) : reject(new Error('Could not export image'));\n                    }, format, quality);\n                });\n            }));\n        });\n    }\n}\nRenderer.MAX_CANVAS_WIDTH = 4000;\nexport default Renderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}