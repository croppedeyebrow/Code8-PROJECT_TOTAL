{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport Decoder from './decoder.js';\nimport Fetcher from './fetcher.js';\nimport Player from './player.js';\nimport Renderer from './renderer.js';\nimport Timer from './timer.js';\nimport WebAudioPlayer from './webaudio.js';\nconst defaultOptions = {\n  waveColor: '#999',\n  progressColor: '#555',\n  cursorWidth: 1,\n  minPxPerSec: 0,\n  fillParent: true,\n  interact: true,\n  dragToSeek: false,\n  autoScroll: true,\n  autoCenter: true,\n  sampleRate: 8000\n};\nclass WaveSurfer extends Player {\n  /** Create a new WaveSurfer instance */\n  static create(options) {\n    return new WaveSurfer(options);\n  }\n  /** Create a new WaveSurfer instance */\n  constructor(options) {\n    const media = options.media || (options.backend === 'WebAudio' ? new WebAudioPlayer() : undefined);\n    super({\n      media,\n      mediaControls: options.mediaControls,\n      autoplay: options.autoplay,\n      playbackRate: options.audioRate\n    });\n    this.plugins = [];\n    this.decodedData = null;\n    this.subscriptions = [];\n    this.mediaSubscriptions = [];\n    this.options = Object.assign({}, defaultOptions, options);\n    this.timer = new Timer();\n    const audioElement = media ? undefined : this.getMediaElement();\n    this.renderer = new Renderer(this.options, audioElement);\n    this.initPlayerEvents();\n    this.initRendererEvents();\n    this.initTimerEvents();\n    this.initPlugins();\n    // Load audio if URL or an external media with an src is passed,\n    // of render w/o audio if pre-decoded peaks and duration are provided\n    const url = this.options.url || this.getSrc() || '';\n    if (url || this.options.peaks && this.options.duration) {\n      this.load(url, this.options.peaks, this.options.duration);\n    }\n  }\n  initTimerEvents() {\n    // The timer fires every 16ms for a smooth progress animation\n    this.subscriptions.push(this.timer.on('tick', () => {\n      const currentTime = this.getCurrentTime();\n      this.renderer.renderProgress(currentTime / this.getDuration(), true);\n      this.emit('timeupdate', currentTime);\n      this.emit('audioprocess', currentTime);\n    }));\n  }\n  initPlayerEvents() {\n    if (this.isPlaying()) {\n      this.emit('play');\n      this.timer.start();\n    }\n    this.mediaSubscriptions.push(this.onMediaEvent('timeupdate', () => {\n      const currentTime = this.getCurrentTime();\n      this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());\n      this.emit('timeupdate', currentTime);\n    }), this.onMediaEvent('play', () => {\n      this.emit('play');\n      this.timer.start();\n    }), this.onMediaEvent('pause', () => {\n      this.emit('pause');\n      this.timer.stop();\n    }), this.onMediaEvent('emptied', () => {\n      this.timer.stop();\n    }), this.onMediaEvent('ended', () => {\n      this.emit('finish');\n    }), this.onMediaEvent('seeking', () => {\n      this.emit('seeking', this.getCurrentTime());\n    }));\n  }\n  initRendererEvents() {\n    this.subscriptions.push(\n    // Seek on click\n    this.renderer.on('click', (relativeX, relativeY) => {\n      if (this.options.interact) {\n        this.seekTo(relativeX);\n        this.emit('interaction', relativeX * this.getDuration());\n        this.emit('click', relativeX, relativeY);\n      }\n    }),\n    // Double click\n    this.renderer.on('dblclick', (relativeX, relativeY) => {\n      this.emit('dblclick', relativeX, relativeY);\n    }),\n    // Scroll\n    this.renderer.on('scroll', (startX, endX) => {\n      const duration = this.getDuration();\n      this.emit('scroll', startX * duration, endX * duration);\n    }),\n    // Redraw\n    this.renderer.on('render', () => {\n      this.emit('redraw');\n    }));\n    // Drag\n    {\n      let debounce;\n      this.subscriptions.push(this.renderer.on('drag', relativeX => {\n        if (!this.options.interact) return;\n        // Update the visual position\n        this.renderer.renderProgress(relativeX);\n        // Set the audio position with a debounce\n        clearTimeout(debounce);\n        debounce = setTimeout(() => {\n          this.seekTo(relativeX);\n        }, this.isPlaying() ? 0 : 200);\n        this.emit('interaction', relativeX * this.getDuration());\n        this.emit('drag', relativeX);\n      }));\n    }\n  }\n  initPlugins() {\n    var _a;\n    if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length)) return;\n    this.options.plugins.forEach(plugin => {\n      this.registerPlugin(plugin);\n    });\n  }\n  unsubscribePlayerEvents() {\n    this.mediaSubscriptions.forEach(unsubscribe => unsubscribe());\n    this.mediaSubscriptions = [];\n  }\n  /** Set new wavesurfer options and re-render it */\n  setOptions(options) {\n    this.options = Object.assign({}, this.options, options);\n    this.renderer.setOptions(this.options);\n    if (options.audioRate) {\n      this.setPlaybackRate(options.audioRate);\n    }\n    if (options.mediaControls != null) {\n      this.getMediaElement().controls = options.mediaControls;\n    }\n  }\n  /** Register a wavesurfer.js plugin */\n  registerPlugin(plugin) {\n    plugin.init(this);\n    this.plugins.push(plugin);\n    // Unregister plugin on destroy\n    this.subscriptions.push(plugin.once('destroy', () => {\n      this.plugins = this.plugins.filter(p => p !== plugin);\n    }));\n    return plugin;\n  }\n  /** For plugins only: get the waveform wrapper div */\n  getWrapper() {\n    return this.renderer.getWrapper();\n  }\n  /** Get the current scroll position in pixels */\n  getScroll() {\n    return this.renderer.getScroll();\n  }\n  /** Get all registered plugins */\n  getActivePlugins() {\n    return this.plugins;\n  }\n  loadAudio(url, blob, channelData, duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.emit('load', url);\n      if (!this.options.media && this.isPlaying()) this.pause();\n      this.decodedData = null;\n      // Fetch the entire audio as a blob if pre-decoded data is not provided\n      if (!blob && !channelData) {\n        const onProgress = percentage => this.emit('loading', percentage);\n        blob = yield Fetcher.fetchBlob(url, onProgress, this.options.fetchParams);\n      }\n      // Set the mediaelement source\n      this.setSrc(url, blob);\n      // Wait for the audio duration\n      // It should be a promise to allow event listeners to subscribe to the ready and decode events\n      const audioDuration = (yield Promise.resolve(duration || this.getDuration())) || (yield new Promise(resolve => {\n        this.onceMediaEvent('loadedmetadata', () => resolve(this.getDuration()));\n      }));\n      // Decode the audio data or use user-provided peaks\n      if (channelData) {\n        this.decodedData = Decoder.createBuffer(channelData, audioDuration || 0);\n      } else if (blob) {\n        const arrayBuffer = yield blob.arrayBuffer();\n        this.decodedData = yield Decoder.decode(arrayBuffer, this.options.sampleRate);\n      }\n      if (this.decodedData) {\n        this.emit('decode', this.getDuration());\n        this.renderer.render(this.decodedData);\n      }\n      this.emit('ready', this.getDuration());\n    });\n  }\n  /** Load an audio file by URL, with optional pre-decoded audio data */\n  load(url, channelData, duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.loadAudio(url, undefined, channelData, duration);\n    });\n  }\n  /** Load an audio blob */\n  loadBlob(blob, channelData, duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.loadAudio('blob', blob, channelData, duration);\n    });\n  }\n  /** Zoom the waveform by a given pixels-per-second factor */\n  zoom(minPxPerSec) {\n    if (!this.decodedData) {\n      throw new Error('No audio loaded');\n    }\n    this.renderer.zoom(minPxPerSec);\n    this.emit('zoom', minPxPerSec);\n  }\n  /** Get the decoded audio data */\n  getDecodedData() {\n    return this.decodedData;\n  }\n  /** Get decoded peaks */\n  exportPeaks() {\n    let {\n      channels = 2,\n      maxLength = 8000,\n      precision = 10000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.decodedData) {\n      throw new Error('The audio has not been decoded yet');\n    }\n    const maxChannels = Math.min(channels, this.decodedData.numberOfChannels);\n    const peaks = [];\n    for (let i = 0; i < maxChannels; i++) {\n      const channel = this.decodedData.getChannelData(i);\n      const data = [];\n      const sampleSize = Math.round(channel.length / maxLength);\n      for (let i = 0; i < maxLength; i++) {\n        const sample = channel.slice(i * sampleSize, (i + 1) * sampleSize);\n        let max = 0;\n        for (let x = 0; x < sample.length; x++) {\n          const n = sample[x];\n          if (Math.abs(n) > Math.abs(max)) max = n;\n        }\n        data.push(Math.round(max * precision) / precision);\n      }\n      peaks.push(data);\n    }\n    return peaks;\n  }\n  /** Get the duration of the audio in seconds */\n  getDuration() {\n    let duration = super.getDuration() || 0;\n    // Fall back to the decoded data duration if the media duration is incorrect\n    if ((duration === 0 || duration === Infinity) && this.decodedData) {\n      duration = this.decodedData.duration;\n    }\n    return duration;\n  }\n  /** Toggle if the waveform should react to clicks */\n  toggleInteraction(isInteractive) {\n    this.options.interact = isInteractive;\n  }\n  /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */\n  seekTo(progress) {\n    const time = this.getDuration() * progress;\n    this.setTime(time);\n  }\n  /** Play or pause the audio */\n  playPause() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.isPlaying() ? this.pause() : this.play();\n    });\n  }\n  /** Stop the audio and go to the beginning */\n  stop() {\n    this.pause();\n    this.setTime(0);\n  }\n  /** Skip N or -N seconds from the current position */\n  skip(seconds) {\n    this.setTime(this.getCurrentTime() + seconds);\n  }\n  /** Empty the waveform */\n  empty() {\n    this.load('', [[0]], 0.001);\n  }\n  /** Set HTML media element */\n  setMediaElement(element) {\n    this.unsubscribePlayerEvents();\n    super.setMediaElement(element);\n    this.initPlayerEvents();\n  }\n  exportImage() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n    let quality = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'dataURL';\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.renderer.exportImage(format, quality, type);\n    });\n  }\n  /** Unmount wavesurfer */\n  destroy() {\n    this.emit('destroy');\n    this.plugins.forEach(plugin => plugin.destroy());\n    this.subscriptions.forEach(unsubscribe => unsubscribe());\n    this.unsubscribePlayerEvents();\n    this.timer.destroy();\n    this.renderer.destroy();\n    super.destroy();\n  }\n}\nexport default WaveSurfer;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Decoder","Fetcher","Player","Renderer","Timer","WebAudioPlayer","defaultOptions","waveColor","progressColor","cursorWidth","minPxPerSec","fillParent","interact","dragToSeek","autoScroll","autoCenter","sampleRate","WaveSurfer","create","options","constructor","media","backend","undefined","mediaControls","autoplay","playbackRate","audioRate","plugins","decodedData","subscriptions","mediaSubscriptions","Object","assign","timer","audioElement","getMediaElement","renderer","initPlayerEvents","initRendererEvents","initTimerEvents","initPlugins","url","getSrc","peaks","duration","load","push","on","currentTime","getCurrentTime","renderProgress","getDuration","emit","isPlaying","start","onMediaEvent","stop","relativeX","relativeY","seekTo","startX","endX","debounce","clearTimeout","setTimeout","_a","length","forEach","plugin","registerPlugin","unsubscribePlayerEvents","unsubscribe","setOptions","setPlaybackRate","controls","init","once","filter","p","getWrapper","getScroll","getActivePlugins","loadAudio","blob","channelData","pause","onProgress","percentage","fetchBlob","fetchParams","setSrc","audioDuration","onceMediaEvent","createBuffer","arrayBuffer","decode","render","loadBlob","zoom","Error","getDecodedData","exportPeaks","channels","maxLength","precision","arguments","maxChannels","Math","min","numberOfChannels","i","channel","getChannelData","data","sampleSize","round","sample","slice","max","x","n","abs","Infinity","toggleInteraction","isInteractive","progress","time","setTime","playPause","play","skip","seconds","empty","setMediaElement","element","exportImage","format","quality","type","destroy"],"sources":["C:/dev/PROJECT_TOTAL/src/main/react/node_modules/wavesurfer.js/dist/wavesurfer.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Decoder from './decoder.js';\nimport Fetcher from './fetcher.js';\nimport Player from './player.js';\nimport Renderer from './renderer.js';\nimport Timer from './timer.js';\nimport WebAudioPlayer from './webaudio.js';\nconst defaultOptions = {\n    waveColor: '#999',\n    progressColor: '#555',\n    cursorWidth: 1,\n    minPxPerSec: 0,\n    fillParent: true,\n    interact: true,\n    dragToSeek: false,\n    autoScroll: true,\n    autoCenter: true,\n    sampleRate: 8000,\n};\nclass WaveSurfer extends Player {\n    /** Create a new WaveSurfer instance */\n    static create(options) {\n        return new WaveSurfer(options);\n    }\n    /** Create a new WaveSurfer instance */\n    constructor(options) {\n        const media = options.media ||\n            (options.backend === 'WebAudio' ? new WebAudioPlayer() : undefined);\n        super({\n            media,\n            mediaControls: options.mediaControls,\n            autoplay: options.autoplay,\n            playbackRate: options.audioRate,\n        });\n        this.plugins = [];\n        this.decodedData = null;\n        this.subscriptions = [];\n        this.mediaSubscriptions = [];\n        this.options = Object.assign({}, defaultOptions, options);\n        this.timer = new Timer();\n        const audioElement = media ? undefined : this.getMediaElement();\n        this.renderer = new Renderer(this.options, audioElement);\n        this.initPlayerEvents();\n        this.initRendererEvents();\n        this.initTimerEvents();\n        this.initPlugins();\n        // Load audio if URL or an external media with an src is passed,\n        // of render w/o audio if pre-decoded peaks and duration are provided\n        const url = this.options.url || this.getSrc() || '';\n        if (url || (this.options.peaks && this.options.duration)) {\n            this.load(url, this.options.peaks, this.options.duration);\n        }\n    }\n    initTimerEvents() {\n        // The timer fires every 16ms for a smooth progress animation\n        this.subscriptions.push(this.timer.on('tick', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), true);\n            this.emit('timeupdate', currentTime);\n            this.emit('audioprocess', currentTime);\n        }));\n    }\n    initPlayerEvents() {\n        if (this.isPlaying()) {\n            this.emit('play');\n            this.timer.start();\n        }\n        this.mediaSubscriptions.push(this.onMediaEvent('timeupdate', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());\n            this.emit('timeupdate', currentTime);\n        }), this.onMediaEvent('play', () => {\n            this.emit('play');\n            this.timer.start();\n        }), this.onMediaEvent('pause', () => {\n            this.emit('pause');\n            this.timer.stop();\n        }), this.onMediaEvent('emptied', () => {\n            this.timer.stop();\n        }), this.onMediaEvent('ended', () => {\n            this.emit('finish');\n        }), this.onMediaEvent('seeking', () => {\n            this.emit('seeking', this.getCurrentTime());\n        }));\n    }\n    initRendererEvents() {\n        this.subscriptions.push(\n        // Seek on click\n        this.renderer.on('click', (relativeX, relativeY) => {\n            if (this.options.interact) {\n                this.seekTo(relativeX);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('click', relativeX, relativeY);\n            }\n        }), \n        // Double click\n        this.renderer.on('dblclick', (relativeX, relativeY) => {\n            this.emit('dblclick', relativeX, relativeY);\n        }), \n        // Scroll\n        this.renderer.on('scroll', (startX, endX) => {\n            const duration = this.getDuration();\n            this.emit('scroll', startX * duration, endX * duration);\n        }), \n        // Redraw\n        this.renderer.on('render', () => {\n            this.emit('redraw');\n        }));\n        // Drag\n        {\n            let debounce;\n            this.subscriptions.push(this.renderer.on('drag', (relativeX) => {\n                if (!this.options.interact)\n                    return;\n                // Update the visual position\n                this.renderer.renderProgress(relativeX);\n                // Set the audio position with a debounce\n                clearTimeout(debounce);\n                debounce = setTimeout(() => {\n                    this.seekTo(relativeX);\n                }, this.isPlaying() ? 0 : 200);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('drag', relativeX);\n            }));\n        }\n    }\n    initPlugins() {\n        var _a;\n        if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length))\n            return;\n        this.options.plugins.forEach((plugin) => {\n            this.registerPlugin(plugin);\n        });\n    }\n    unsubscribePlayerEvents() {\n        this.mediaSubscriptions.forEach((unsubscribe) => unsubscribe());\n        this.mediaSubscriptions = [];\n    }\n    /** Set new wavesurfer options and re-render it */\n    setOptions(options) {\n        this.options = Object.assign({}, this.options, options);\n        this.renderer.setOptions(this.options);\n        if (options.audioRate) {\n            this.setPlaybackRate(options.audioRate);\n        }\n        if (options.mediaControls != null) {\n            this.getMediaElement().controls = options.mediaControls;\n        }\n    }\n    /** Register a wavesurfer.js plugin */\n    registerPlugin(plugin) {\n        plugin.init(this);\n        this.plugins.push(plugin);\n        // Unregister plugin on destroy\n        this.subscriptions.push(plugin.once('destroy', () => {\n            this.plugins = this.plugins.filter((p) => p !== plugin);\n        }));\n        return plugin;\n    }\n    /** For plugins only: get the waveform wrapper div */\n    getWrapper() {\n        return this.renderer.getWrapper();\n    }\n    /** Get the current scroll position in pixels */\n    getScroll() {\n        return this.renderer.getScroll();\n    }\n    /** Get all registered plugins */\n    getActivePlugins() {\n        return this.plugins;\n    }\n    loadAudio(url, blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit('load', url);\n            if (!this.options.media && this.isPlaying())\n                this.pause();\n            this.decodedData = null;\n            // Fetch the entire audio as a blob if pre-decoded data is not provided\n            if (!blob && !channelData) {\n                const onProgress = (percentage) => this.emit('loading', percentage);\n                blob = yield Fetcher.fetchBlob(url, onProgress, this.options.fetchParams);\n            }\n            // Set the mediaelement source\n            this.setSrc(url, blob);\n            // Wait for the audio duration\n            // It should be a promise to allow event listeners to subscribe to the ready and decode events\n            const audioDuration = (yield Promise.resolve(duration || this.getDuration())) ||\n                (yield new Promise((resolve) => {\n                    this.onceMediaEvent('loadedmetadata', () => resolve(this.getDuration()));\n                }));\n            // Decode the audio data or use user-provided peaks\n            if (channelData) {\n                this.decodedData = Decoder.createBuffer(channelData, audioDuration || 0);\n            }\n            else if (blob) {\n                const arrayBuffer = yield blob.arrayBuffer();\n                this.decodedData = yield Decoder.decode(arrayBuffer, this.options.sampleRate);\n            }\n            if (this.decodedData) {\n                this.emit('decode', this.getDuration());\n                this.renderer.render(this.decodedData);\n            }\n            this.emit('ready', this.getDuration());\n        });\n    }\n    /** Load an audio file by URL, with optional pre-decoded audio data */\n    load(url, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio(url, undefined, channelData, duration);\n        });\n    }\n    /** Load an audio blob */\n    loadBlob(blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio('blob', blob, channelData, duration);\n        });\n    }\n    /** Zoom the waveform by a given pixels-per-second factor */\n    zoom(minPxPerSec) {\n        if (!this.decodedData) {\n            throw new Error('No audio loaded');\n        }\n        this.renderer.zoom(minPxPerSec);\n        this.emit('zoom', minPxPerSec);\n    }\n    /** Get the decoded audio data */\n    getDecodedData() {\n        return this.decodedData;\n    }\n    /** Get decoded peaks */\n    exportPeaks({ channels = 2, maxLength = 8000, precision = 10000 } = {}) {\n        if (!this.decodedData) {\n            throw new Error('The audio has not been decoded yet');\n        }\n        const maxChannels = Math.min(channels, this.decodedData.numberOfChannels);\n        const peaks = [];\n        for (let i = 0; i < maxChannels; i++) {\n            const channel = this.decodedData.getChannelData(i);\n            const data = [];\n            const sampleSize = Math.round(channel.length / maxLength);\n            for (let i = 0; i < maxLength; i++) {\n                const sample = channel.slice(i * sampleSize, (i + 1) * sampleSize);\n                let max = 0;\n                for (let x = 0; x < sample.length; x++) {\n                    const n = sample[x];\n                    if (Math.abs(n) > Math.abs(max))\n                        max = n;\n                }\n                data.push(Math.round(max * precision) / precision);\n            }\n            peaks.push(data);\n        }\n        return peaks;\n    }\n    /** Get the duration of the audio in seconds */\n    getDuration() {\n        let duration = super.getDuration() || 0;\n        // Fall back to the decoded data duration if the media duration is incorrect\n        if ((duration === 0 || duration === Infinity) && this.decodedData) {\n            duration = this.decodedData.duration;\n        }\n        return duration;\n    }\n    /** Toggle if the waveform should react to clicks */\n    toggleInteraction(isInteractive) {\n        this.options.interact = isInteractive;\n    }\n    /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */\n    seekTo(progress) {\n        const time = this.getDuration() * progress;\n        this.setTime(time);\n    }\n    /** Play or pause the audio */\n    playPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.isPlaying() ? this.pause() : this.play();\n        });\n    }\n    /** Stop the audio and go to the beginning */\n    stop() {\n        this.pause();\n        this.setTime(0);\n    }\n    /** Skip N or -N seconds from the current position */\n    skip(seconds) {\n        this.setTime(this.getCurrentTime() + seconds);\n    }\n    /** Empty the waveform */\n    empty() {\n        this.load('', [[0]], 0.001);\n    }\n    /** Set HTML media element */\n    setMediaElement(element) {\n        this.unsubscribePlayerEvents();\n        super.setMediaElement(element);\n        this.initPlayerEvents();\n    }\n    exportImage(format = 'image/png', quality = 1, type = 'dataURL') {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.renderer.exportImage(format, quality, type);\n        });\n    }\n    /** Unmount wavesurfer */\n    destroy() {\n        this.emit('destroy');\n        this.plugins.forEach((plugin) => plugin.destroy());\n        this.subscriptions.forEach((unsubscribe) => unsubscribe());\n        this.unsubscribePlayerEvents();\n        this.timer.destroy();\n        this.renderer.destroy();\n        super.destroy();\n    }\n}\nexport default WaveSurfer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}